# 概念

## 几种常见的内存问题
1. 内存泄漏(check 类是否可以解决)
   1. 概念：当进程不再需要某些内存的时候，这些内存不能被回收
   2. js中造成内存泄漏主要是不在需要的内存数据仍然被其他对象引用；
   ```javascript
    function foo(){
        abc =  {}
    }
    1. 在浏览器默认情况下如果不在function 里面生命var 或者let，
    默认会将abc挂在到window上，window是常驻内存的，
    所以及时foo函数退出 abc仍然被window引用，这样就造成常驻内存，属于内存泄漏

    function foo(){ 
        var object = new Object() 
        object.x = 1 
        object.y = 2 
        object.array = new Array(200000) /** * 使用object */ 
    //     let closure = object.x 
        return function(){ 
            console.log(object.array); 
        }
    }
    foo()()

    3. 闭包 由于返回的匿名函数引用了foo函数中的object.array 
    所以当函数执行完成的时候，object就被遗忘，不能被回收,
    虽然我们只是用了array，但是会造成整个object都留在内存中，
    所以使用闭包的时候，尽量的减少被引用数据的大小，
   ```
2. 内存膨胀
   1. 概念：内存在短时间内急速增长并且达到峰值，
   2. 原因：过多使用内存，引用不必要并且不能的到释放的内容，
   3. 例子：
      1. 我们使用canvas 时候可以一次性构图完成在进行绘图，但是程序员过多操作绘画并不进行释放
      2. 在同一个方法时频繁操作dom，并且不设置null
   
3. 频繁的垃圾回收
    除了内存泄漏和内存膨胀，还有另外一类内存问题，那就是频繁使用大的临时变量，导致了新生代空间很快被装满，从而频繁触发垃圾回收。频繁的垃圾回收操作会让你感觉到页面卡顿
    


## 垃圾数据的产生
```javascript
    当数据被存放到堆栈中，通常是在内存中创建一块空间，
    但是当引用该空间的指针指向了其他空间，这部分空间就属于垃圾数据的空间，需要被回收；
    var a = {};
    a.x = new Array(100);// 会在内存中开辟一个空间；
    a.x = new Object();// 会改变引用空间
    
    这种情况就会会受到newArray的空间；

```

## 垃圾回收的流程

1. 通过GC Root 标记空间的活动对象和非活动对象。
- 通过GC Root 遍历到的对象，我们就认为该对象使可访问的，那么就要保存这些对象在内存中，也称这个对象为活动对象
- 通过GC Root没有遍历到的对象，则是不可访问的，那么这些对象就可能会被回收，称非活动对象
- GC Root 有很多种：例如window对象，文档dom树，存放在栈上的变量等
2. 回收非活动对象所占据的内存，其实就是在所有的标记完成后，统一清楚内存中所有标记可回收的对象
3. 做内存整理，碎片话内存整理称统一内存；

### 主回收器，副回收器

[知乎文章](https://zhuanlan.zhihu.com/p/259579683)


